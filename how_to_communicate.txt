審判サーバの動作、レイトレの入出力の実態、I/Oの実装方法について。
意見質問などはお気軽に私まで。むしろ何かフィードバックをください、ないと寂しいです笑。(by m)

●審判サーバの動作
○実行時引数
オプション
  -b       : 送信データをビッグエンディアンに変換(デフォルトはリトルエンディアン)
  -B [arg] : ボーレート指定(デフォルトは115200)
  -c [arg] : COMポートID指定(デフォルトは1)
  -C       : CTSを使ったフロー制御を行う
  -p [arg] : パリティタイプ指定(デフォルトはIGNPAR)(パリティはなしで固定されている)
  -P  	   : ストップビットの長さ(デフォルトは0)(このオプションは無視される)
  実際に使うのは-b,-Bくらいだと思う
SLDファイルパス
  レイトレの入力ファイル
PPMファイルパス
  レイトレの出力ファイル

○動作の流れ
SLDデータを読み込む
 - 実行時引数で指定された.sldファイルのスペース,改行で区切られた数字を全て、先頭から32bitバイナリ表現にして配列fi_union sld_words[]に詰めていく(スペース,改行は取り除かれる)
 - fi_unionはint型とfloat型の共用体の型

基盤から0xaaが送信されるのを待つ
 - 0xaaが基盤からの準備完了の合図となっている
 - 基盤はこれより前には0xaa以外のどの値を送信しても良い(審判サーバは0xaa以外の値を無視する)

SLDデータを送信する
 - 0xaaを受信したら、gettimeofdayで時間を計測してデータの送信を始める
 - SLDデータを詰めた配列(char*) sld_wordsの先頭から1バイトずつ送信する

PPMデータを受信する
 - 実行時引数で指定された.ppmファイルに受信したデータを出力する(つまり勝手に画像が表示される)

●レイトレの入出力
○SLDデータの入力
レイトレのプログラムは文字列として受信する実装だが、審判サーバはバイナリとして送信する実装になっている。
審判サーバが、.sldファイルに書かれた全ての数字を32bitバイナリ表現に変換して1バイトずつ続けて送信するので、レイトレで用いるライブラリ関数read_int,read_floatをこれに対応した実装に変更する必要がある。
与えられた実装では、read_int,read_floatは文字列を数値に変換している。つまり、標準入力から1文字ずつ読み込み、'1','2','.','3',' 'を受信したら1つのトークン"12.3"と解釈して数値12.3に変換する、という操作を行う。
バイナリに対応するとは、要するにI/Oコントローラから1ワード取り込んでRレジスタまたはFレジスタに取り込めば良いので、ロード命令を使って実装できると思う(1バイトずつ送られるデータをI/Oコントローラが先頭から4バイトずつ纏めて1ワードのデータとして扱う)。

○PPMデータの出力
こちらはデフォルトでは、レイトレのプログラムと審判サーバで実装にずれがない。
つまり、レイトレのプログラムは文字列として送信する実装で、審判サーバも文字列として受信する実装になっている。
バージョンがP3、画像の縦横のサイズがともに128、最大照度が255のとき、PPMヘッダは"P3\n128 128 255\n"という文字列として送信される。floatで計算されたあるピクセルのRGB値が、0以上255以下のintに変換されてそれぞれ0,255,255であるとき、そのピクセルの値は"0 255 255\n"という文字列として送信される。
従って、出力されるPPMデータは"P3\n128 128 255\n0 255 255\n255 255 0\n(以下ピクセルの値の繰り返し)"のようになる。
レイトレで用いるライブラリ関数print_char,print_intの実装は、print_char 32なら"00100000"(数値32の8bitバイナリ表現)を送信し、print_int 255なら"00110010","00110101","00110101"(それぞれ文字'2','5','5'のASCIIコード)を順に送信するようにすれば良い。
コア内で数値は32bitで表現されているので、その下位8bitに対するストア命令を使って実装できると思う(下位8bitのストア命令について詳細は後述)。

レイトレのプログラムはバージョンとしてP3を設定するように書かれているが、これをP6に変更することが許可されている。
バージョンは各ピクセルのRGB値の送信方法を指定する。つまり、バージョンがP3の場合は、上で見たように各ピクセルのRGB値は文字列として送信されるが、バージョンがP6の場合は、各ピクセルの値は8bitバイナリ表現として送信される。
審判サーバには、PPMヘッダのバージョンがP6のときにRGB値をバイナリとして解釈する機能が備わっているので問題ないが、レイトレのプログラムにはP6に対応した関数がない。
そこでP6を用いる場合には、レイトレのプログラム中で定義されている関数write_ppm_header,write_rgb_element,write_rgbの定義を一部変更する必要がある(この変更は許可されている:cpuex2012/rules/opt_rules.txt)。たぶんwrite_rgb_elementのprint_intをprint_charに置き換えれば良いと思う。
ただし、P6でバイナリ表現になるのは各ピクセルのRGB値のみで、PPMヘッダ中の数値はどちらのバージョンでもバイナリ表現ではなく文字列で表現されることに注意。従ってP6を用いる場合のwrite_ppm_headerの変更箇所は(* +6 if binary *)とコメントされている部分のみである。

●コアにおけるI/Oの実装
特別にI/O用の命令を用意するのではなく、ロード/ストア命令を用いるメモリマップ方式で実装する。
メモリ(SRAM)の容量は4Mバイトつまり1Mワードであり、そのアドレスは20bitで表現される。ロード/ストア命令で指定できるアドレスは32bit分あるので、メモリのアドレスの最大値を超えたある値をアドレスとして指定したロード/ストア命令を、メモリでなくI/Oコントローラとデータをやり取りするものとして扱う。

上で見てきたように、レイトレのプログラムにおいて入力データを読み込むこと(read_float,read_int)はコアにおいてI/Oコントローラから1ワード読むことであり、出力データを書き出すこと(print_char,print_int)はI/Oコントローラに1バイト書くことである。
よってこの動作の実現に必要なのは、I/Oコントローラに対するワード単位のロード命令とバイト単位のストア命令となる。

そこでロード/ストア命令で指定されるアドレスを次のように解釈することにする(アドレスの各ビットを上位から順に[31],...,[0]と表記する)。
 - 最上位ビット[31]=='1'のとき、この命令はI/Oコントローラに対するロード/ストア命令である。
    - [31-30]=="11"のとき、この命令はI/Oコントローラに対するロード命令である。よってI/Oコントローラの受信バッファから1ワードを読み出して指定されたレジスタに書き込む。
    - [31-30]=="10"のとき、この命令はI/Oコントローラに対するストア命令である。このとき、[29-28]の値に応じて、指定されたレジスタの対応するバイトを読み出してI/Oコントローラの送信バッファに書き込む("00"なら[7-0]、"01"なら[15-8]、"10"なら[23-16]、"11"なら[31-24]といった具合)。
 - 最上位ビット[31]=='0'のとき、この命令はメモリに対するロード/ストア命令である。指定されたアドレスの下位20ビットをアドレスとしてメモリとデータのやり取りをする(メモリに対して2^10を超えるアドレスを指定できるがそのときは2^10のmodがアドレスに使われる、ということになるが、実際0以上2^10未満の値しか指定しないということで)。
