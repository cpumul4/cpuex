fpuの各モジュールの動作と、それぞれの具体的な実装方法

以下で実装の条件を満たすはずだが、しっかり検証したわけではないので、コーナーケースなど何かあれば遠慮なくつっこんで下さい。

また、動作速度や回路面積、ゲート数、精度との兼ね合いなどはよく分かっていないので、そういう面で改善点や気になる点がありましたら教えて下さい。こちらでも気づき次第訂正します。いつ何を訂正したかは、同じディレクトリのupdate.txtを参照してください。

最初に、このfpuで扱うのはIEEE754の単精度であるが、通常と違う点が二つある

1.非正規数と正規化数は区別せず同様に演算する。ただし0(とみなされる)数での演算は例外である
2.指数部が0の数は0とみなす

以上を簡単にまとめると、"例外処理は省略している"ということである。

また丸めは、"最近接丸め"である。ちょうど中間のときは最下位bitが0になるように丸める

1.fpuの各モジュールのおおまかな動作

fadd

1.絶対値を比較して、指数の差の分だけ絶対値の小さい方の仮数をシフトする。絶対値が大きい方の指数は和の指数に使う
2.符号に応じて、1でシフトした仮数を足すなり引くなりする。ここで、後の丸めのためにガードビット、ラウンドビット、スティッキービットまで求める
3.丸め処理や正規化を行う。正規化でシフトする際にexpが負になった場合もシフトは先頭の0の個数だけする。その後expが負だった場合はexp=0とする
※小さい方が0(とみなされる数)のときは、大きい方をそのまま返す

faddは2パス浮動小数点加算器にしてみる。(ゲート数が増えるようなので逆効果になるかも知れないが)
詳しくは下の具体的な実装方法で


fmul

1.サインビットは入力の二数のサインビットのxor。
2.仮数部の積を求めて丸めや正規化を行う。
3.expは二数のexpの和に129を足したものの下位8bitだが、正規化や丸めの後で9bit目が0だった場合アンダーフローが起きたとしてexp=0にする(オーバーフローの可能性もあるが)
※0(とみなされる数)での積は、サインビットはxorをし、exp=0とし、仮数部は一つ目の入力の仮数部をそのままつかう

fmulでの仮数部での乗算は3bitのブースエンコーダで実装するつもりである
詳しくは下の具体的な実装法方で


fdiv

1.サインビットは入力の二数のサインビットのxor。
2.仮数部の商を求めて丸めや正規化を行う。丸めのためのスティッキービットの代わりに余りを考える
3.expは二数のexpの差に127を足したものの下位8bitだが、正規化や丸めの後で9bit目が1だった場合アンダーフローが起きたとしてexp=0にする(オーバーフローの可能性もあるが)
※0(とみなされる数)での積は、サインビットはxorをし、exp=255とし、仮数部は一つ目の入力の仮数部をそのままつかう

ニュートン法は精度がどうなるかよく分からなかったので、とりあえず避けた。
fdivでの仮数部での除算はSRT法で実装するつもりである
詳しくは下の具体的な実装法方で


sqrt

1.指数部が奇数(127が足されているのでビットだけみたら偶数)のときはexpを+1、仮数部を右に1bitシフト。
  指数部が偶数ならばexpを+2、仮数部を右に2bitシフト
2.exp = (exp - 127)/2 + 127
3.二乗して元の仮数部を越えないように、上位ビットから求めていく
4.正規化と丸めを行う

sqrtでもSRT法を応用して上の3では、2ビットずつ求める


feq

基本的に全bitを比較して完全一致をみる。ただし、指数部が0の場合は指数部だけ比較


fle

サインビット、指数部、仮数部をそれぞれ比較する。ただし指数部が0のときは仮数部は無視する


2.具体的な実装方法

随時更新します
