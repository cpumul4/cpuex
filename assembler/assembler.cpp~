#include "../simulator/common.h"
#include "opcode.h"
#include <stdint.h>
#include <stdlib.h>
#include <cstring>
#include <iostream>
#include <fstream>
using namespace std;
#define MAX_CHAR  30
#define MAX_LINE  10000
#define LABEL_TABLE_NUM 1000



// opcode

class ltable {
  uint index[LABEL_TABLE_NUM];
  char *label[LABEL_TABLE_NUM];
public:
  ltable(){
    for(int i = 0; i < LABEL_TABLE_NUM;i++)
      label[i] = NULL;
  }
  void set_label(uint ,const char *);
  int get_index(const char *);
};

void ltable::set_label(uint i, const char *l){
  uint itr = 0;
  while(label[itr] != NULL)itr++;
  label[itr] = (char *)malloc(sizeof(char) * strlen(l));
  strcpy(label[itr],l);
  index[itr] = i;
}

int ltable::get_index(const char *_label){
  uint i = 0;
  while(label[i] != NULL && strcmp(_label,label[i]) != 0)i++;
  if(label[i] != NULL)
    return index[i];		// FIND

  return -1;  			// ERROR
}
    


inline int get_regnum(char *reg){
  if(reg[0] == '$'){
    if(reg[1] == 'r' || reg[1] == 'f')
      return (int)atoi(reg + 2);
  }
  else 
    return -1;
}


enum format { r, i, j};

format dec_operator(char *op, int &opcode, int &funct){


#define subst(opstr,opc,fnc) opcode = opc ## opstr; funct = fnc ## opstr;
#define op(_op) if(strcmp(op,#_op) == 0){subst(_op, opc_, fnc_)}

  op(add)
  else op(sub)
  else op(sub)
  else op(sub)
  else op(sub)
  else op(sub)
  else op(sub)
  else op(sub)
	 

	 ;
#undef subst
#undef op

  if(opcode > 0b100000)
    return r;
  else if(opcode == 0b011111 || opcode == 0b0111110)
    return j;
  else 
    return i;
}

char *skip_chars(char *str, const char *keys){
  int i = 0;
  for(;str[i] != 0;i++)
    if(strchr(keys,str[i]) == NULL)
      return str + i;
  return str + i;
}

char *strchrs(char *str, const char *keys){
  for(int i = 0; keys[i] != 0;i++)
    if(strchr(str,keys[i]) != NULL)
      return str + i;
  return NULL;
}

int main(int argc, char *argv[]){
  char delims[] = " \t\r";
  char combegin[] = "#;";

  if(argc != 3){
    cerr << "USAGE: assembler infile outfile\n";
    return 1;
  }

  ifstream fin(argv[1]);
  int inum = 0;
  char input[MAX_LINE][MAX_CHAR];
  uint32_t output[MAX_LINE];
  ltable table;

  while( fin.getline(input[inum], MAX_CHAR) ){
    if(input[inum] == NULL || input[inum][0] == 0){
      continue;
    }
    // コメントの処理
    char *comment;		
    if((comment = strchrs(input[inum], combegin)) != NULL)
      *comment = 0;

    if(strchr(delims,input[inum][0]) == NULL){ // 先頭が空白文字じゃなかったらlabel
       char *label = strtok(input[inum], ":");
       table.set_label(inum,label);
    }


    switch(*skip_chars(input[inum],delims)){
    case 0: case '.':
      continue;
    default:
      inum++;
      break;
    }
  }
  
  

  for(int itr=0; itr< inum; itr++){
  // 命令コード文字列を取り出す
    char *opertstr, *token[4];
    opertstr = skip_chars(input[itr], delims);
    
    int k = 0;
    while(( token[k] = strtok(opertstr, delims) ) != NULL)
      ;

    // 命令コードをopcode, functにする
    int opcode, funct;
    format f = dec_operator(token[0], opcode ,funct);
    switch(f){
    case r:
      int oprd[3], n = 0;
      while(token[n] != NULL){
	oprd[n] = get_regnum(token[n]); // labelが無理
	n++;
      }
      output[itr] = rformbin(opcode,funct,oprd);
      break;

    case i:
      int oprd[3], n = 0;
      while(token[n] != NULL){
	oprd[n] = get_regnum(token[n]); // labelが無理
	if(oprd[n] < 0)
	  oprd[n] = atoi(token[n]); 
	n++;
      }
      output[itr] = iformbin(opcode,oprd);
      break;

    case j:
      int addr = table.get_index(token[1]);
      output[itr] = jformbin(opcode,addr);
      break;
    }
  // 命令コード（命令形式）によってレジスタなどの格納を変えないといけない
  // r,fr,mr = opcode6, reg5*3, amt5, funct6
  // i,fi,mi = opcode6, reg5*1, imm16
  // j = opcode6, addr26

  // レジスタなどの解析
  // 32bit列に治す
  // 出力
  ofstream fout(argv[2]);

  }
}
