命令実行中に参照するプログラムカウンタPCは、次命令のアドレスを指している。

整数レジスタ
0     $zero     // 値を0固定
1     $v 	// 返値
2-5   $a0-$a3	// 引数
6-15  $t0-$t9	// 一時変数(callerが退避)
16-23 $s0-$s7	// 一時変数(calleeが退避)
24-27 $t10-$t13 // 一時変数(callerが退避)
28    $gp	// グローバルポインタ(静的データへのアクセス用)
29    $sp	// スタックポインタ
30    $fp	// フレームポインタ
31    $ra	// 戻り番地(link register)

浮動小数点数レジスタ
0-31  $f0-$f31

word = 32bit

命令形式
 - R   Rレジスタ*3
       opcode(31-26),rs(25-21),rt(20-16),rd(15-11),amt(10-6),func(5-0)
 - I   Rレジスタ*2, 即値(16bit)
       opcode(31-26),rs(25-21),rt(20-16),imm(15-0)
 - J   即値(26bit)
       opcode(31-26),addr(25-0)
 - FR  Fレジスタ*3
       opcode(31-26),fs(25-21),ft(20-16),fd(15-11),amt(10-6),func(5-0)
 - FI  Fレジスタ*2, 即値(16bit)
       opcode(31-26),fs(25-21),ft(20-16),imm(15-0)
 - MR  Rレジスタ*2, Fレジスタ*1
       opcode(31-26),rs(25-21),rt(20-16),fd(15-11),amt(10-6),func(5-0)
 - MI  Rレジスタ*1, Fレジスタ*1, 即値(16bit)
       opcode(31-26),rs(25-21),ft(20-16),imm(15-0)

**算術演算命令**
R  add  rd rs rt   R[rd] = R[rs] + R[rt]
R  sub  rd rs rt   R[rd] = R[rs] - R[rt]

FR addf fd fs ft   F[fd] = F[fs] +. F[ft]
FR subf fd fs ft   F[fd] = F[fs] -. F[ft]
FR mulf fd fs ft   F[fd] = F[fs] *. F[ft]
FR divf fd fs ft   F[fd] = F[fs] /. F[ft]

I  addi rt rs imm  R[rt] = R[rs] + imm
I  subi rt rs imm  R[rt] = R[rs] - imm

**算術演算命令その2**
FR sqrt fd fs      F[fd] = sqrt(F[fs])  // 平方根

**論理演算命令**
R  and  rd rs rt   R[rd] = R[rs] and R[rt]
R  or   rd rs rt   R[rd] = R[rs] or  R[rt]
R  nor  rd rs rt   R[rd] = R[rs] nor R[rt]
R  xor	rd rs rt   R[rd] = R[rs] xor R[rt]

I  andi rt rs imm  R[rt] = R[rs] and imm
I  ori  rt rs imm  R[rt] = R[rs] or  imm

**シフト命令**
R  sll  rd rs amt  R[rd] = R[rs] <<  amt    // shift left logical
R  srl  rd rs amt  R[rd] = R[rs] >>  amt    // shift right logical
R  sra  rd rs amt  R[rd] = R[rs] >>> amt    // shift right arith.

**ロード/ストア命令**
R  lw   rd rs rt   R[rd] = M[R[rs] + R[rt]]    // load word
I  lwi  rt rs imm  R[rt] = M[R[rs] + imm]      // 即値は符号付き
R  sw   rd rs rt   M[R[rs] + R[rt]] = R[rd]    // store word
I  swi  rt rs imm  M[R[rs] + imm] = R[rt]      // 即値は符号付き

MR lwf  fd rs rt   F[fd] = M[R[rs] + R[rt]]
MI lwif ft rs imm  F[ft] = M[R[rs] + imm]
MR swf  fd rs rt   M[R[rs] + R[rt]] = F[fd]
MI swif ft rs imm  M[R[rs] + imm] = F[ft]

**比較命令**
R  cmp  rd rs rt   R[rd] = (R[rs] <= R[rt]) ? 1 : 0    // compare less than or equal
FR cmpf fd fs ft   F[fd] = (F[fs] <= F[ft]) ? 1 : 0

**無条件分岐命令** (@はbit列の連結　ex. 001 @ 101 = 001101)
J  j    addr       PC = PC{31:26} @ addr              // jump
	      // 2**26 = 67,108,864なのでPC{31:26}はおそらく全部0.
	      // よってこの命令は絶対アドレスを指定してjumpするのにほぼ等しいか？[y_som]
J  jl   addr       $ra = PC; PC = PC{31:26} @ addr    // jump and linked
   		       	     	  	      	      // $ra = link register
						      // $raに保存するのはjlの次の命令のアドレス(== PC)
R  jr   rs         PC = R[rs]                         // jump register

**条件分岐命令**
I  beq  rs rt imm  if (R[rs] == R[rt]) PC = PC + imm    // branch on equal
I  bne  rs rt imm  if (R[rs] != R[rt]) PC = PC + imm    // branch on not equal
FI beqf fs ft imm  if (F[fs] == F[ft]) PC = PC + imm
FI bnef fs ft imm  if (F[fs] != F[ft]) PC = PC + imm

**移動命令**
R  mv   rd rs      R[rd] = R[rs]    // move
FR mvf  fd fs      F[fd] = F[fs]

**その他**
-  nop
-  dbg     // シミュレータ用デバッグ命令(コアではnopと同義)
-  halt    // 停止
-  rst     // レジスタをリセット



**********10/09削除***************
R  mul  rs rt      Hi @ Lo = R[rs] * R[rt]
R  div  rs rt      Lo = R[rs] / R[rt]; Hi = R[rs] % R[rt]

R  abs  rd rs      R[rd] = | R[rs] |    // 絶対値
R  neg  rd rs      R[rd] = - (R[rs])    // 符号反転
FR absf fd fs      F[fd] = | F[fs] |
FR negf fd fs      F[fd] = - (F[fs])

R  mfhi rd         R[rd] = Hi    // move from Hi
R  mflo rd         R[rd] = Lo    // move from Lo
