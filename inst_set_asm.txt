命令形式
 - R   Rレジスタ*3
 - I   Rレジスタ*2, 即値(16bit)
 - J   即値(26bit)
 - FR  Fレジスタ*3
 - FI  Fレジスタ*2, 即値(16bit)

**算術演算命令**
R  add  rd rs rt   R[rd] = R[rs] + R[rt]
R  sub  rd rs rt   R[rd] = R[rs] - R[rt]
R  mul  rs rt      Hi @ Lo = R[rs] * R[rt]
R  div  rs rt      Lo = R[rs] / R[rt]; Hi = R[rs] % R[rt]

FR addf fd fs ft   F[fd] = F[fs] +. F[ft]
FR subf fd fs ft   F[fd] = F[fs] -. F[ft]
FR mulf fd fs ft   F[fd] = F[fs] *. F[ft]
FR divf fd fs ft   F[fd] = F[fs] /. F[ft]

I  addi rt rs imm  R[rt] = R[rs] + imm
I  subi rt rs imm  R[rt] = R[rs] - imm

**算術演算命令その2**
R  abs  rt rs      R[rt] = | R[rs] |    // 絶対値
R  neg  rt rs      R[rt] = - (R[rs])    // 符号反転

FR absf ft fs      F[ft] = | F[fs] |
FR negf ft fs      F[ft] = - (F[fs])
FR sqrt ft fs      F[ft] = sqrt(F[fs])  // 平方根

**論理演算命令**
R  and  rd rs rt   R[rd] = R[rs] and R[rt]
R  or   rd rs rt   R[rd] = R[rs] or  R[rt]
R  nor  rd rs rt   R[rd] = R[rs] nor R[rt]

I  andi rt rs imm  R[rt] = R[rs] and imm
I  ori  rt rs imm  R[rt] = R[rs] or  imm

**シフト命令**
I  sll  rt rs amt  R[rt] = R[rs] <<  amt    // shift left logical
I  srl  rt rs amt  R[rt] = R[rs] >>  amt    // shift right logical
I  sra  rt rs amt  R[rt] = R[rs] >>> amt    // shift right arith.

**ロード/ストア命令**
R  lw   rd rs rt   R[rd] = M[R[rs] + R[rt]]
I  lwi  rt rs imm  R[rt] = M[R[rs] + imm]
R  sw   rd rs rt   M[R[rs] + R[rt]] = R[rd]
I  swi  rt rs imm  M[R[rs] + imm] = R[rt]

FR lwf  fd rs rt   F[fd] = M[R[rs] + R[rt]]
FI lwif ft rs imm  F[ft] = M[R[rs] + imm]
FR swf  fd rs rt   M[R[rs] + R[rt]] = F[fd]
FI swif ft rs imm  M[R[rs] + imm] = F[ft]

**比較命令**
R  clt  rd rs rt   R[rd] = (R[rs] < R[rt]) ? 1 : 0
FR cltf fd fs ft   F[fd] = (F[fs] < F[ft]) ? 1 : 0

**無条件分岐命令**
J  j    addr       PC = PC{31:26} @ addr              // jump
J  jl   addr       $ra = PC; PC = PC{31:26} @ addr    // jump and linked
R  jr   rs         PC = R[rs]                         // jump register

**条件分岐命令**
I  beq  rs rt imm  if (R[rs] == R[rt]) PC = PC + imm
I  bne  rs rt imm  if (R[rs] != R[rt]) PC = PC + imm
FI beqf fs ft imm  if (F[fs] == F[ft]) PC = PC + imm
FI bnef fs ft imm  if (F[fs] != F[ft]) PC = PC + imm

**移動命令**
R  mv   rt rs      R[rt] = R[rs]
FR mvf  ft fs      F[ft] = F[fs]
R  mfhi rs         R[rs] = Hi
R  mflo rs         R[rs] = Lo

**その他**
-  nop
-  dbg     // シミュレータ用デバッグ命令(コアではnopと同義)
-  halt    // 停止
-  rst     // レジスタをリセット
